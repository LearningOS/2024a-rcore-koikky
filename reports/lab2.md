# 1.总结
在ch4里构建了虚拟内存管理策略，所以我根据练习要求重写了sys_get_time 和 sys_task_info函数来满足其功能在使用虚拟内存的情况下。在实现这两个函数时，我需要操作处于用户空间的数据，但由于加入了虚拟内存管理，我的得到的是虚拟内存的地址，我不得不从任务管理器TaskManager索引到该任务的用户地址空间MemorySet，然后根据SV39的页表机制寻找到数据的物理地址。此外还应要求加入了两个新的系统调用mmap和munmap，前者用于每个任务申请一段映射在自己用户空间的物理内存，后者用于每个任务释放一段映射在自己用户空间的物理内存。

# 2.简答作业
## Q1.1
0~9位为标志位，10~53位为物理页号，54~63位为保留。标志位中的10bit，每个bit代表该页表项的一种属性，第0位为valid位，表示该页表项是否有效。第1位为read位，表示该页表项是否可读。第2位为write位，表示该页表项是否可写。第3位为execute位，表示该页表项是否可执行。第4位为user位，表示该页表项是否可以在用户级被访问。第5位为global位，表示该页表项是否全局的。第6位为accessed位，表示该页表项是否已被访问过。第7位为dirty位，表示该页表项是否被修改过。第8和第9位为保留。

## Q2.1.1
缺页可能会导致这些问题：
	(1) 执行代码段取指来执行时出现异常。
	(2) 在分配页帧的时候出现异常。
	(3) 在同一内存地址空间里，可能会导致一个虚拟地址被映射两次。

## Q2.1.2
	stval/utval：存放访问时发生缺页异常的虚拟地址、satp ：用于存放页表的基地址和控制位。

## Q2.2.1
好处：
	(1) 提升了系统的处理性能和响应速度。延后加载需要的内容这代表不需要一次性加载所有内容，这段时间可以去处理其他的进程。
	(2) 提高了存储空间的利用率。将存储空间赋予给当下即将用到的内容，避免造成被分配的存储空间资源闲置，结合回收机制，会更大提高利用率。
	(3) 赋予了加载内容时的动态性，如果随时都要及时加载内容，在使用之前如果想要修改或者调整就增加更大的开销与操作。 

## Q2.3.1
大概20MB的空间，计算如下(理想状态下)，因为是连续10G，将10G(假设是对齐)分成以4KB的页面,数量为2641440个，所需要的第三级页表5120个(每个都占满)，而这会用到10个二级页表(每个都占满)，而一级页表只会占10个页表项。所以(5120+10) * 4096 + 10 * 8 = 21012560 Byte，约为20.039MB。

## Q2.3.2
如何实现：
	在进程开始时，只为虚拟地址空间分配页表结构，不分配实际的物理页面。页面第一次被访问时，通过缺页中断处理函数分配物理页面，并更新页表项。

解决方案：
	当发现缺页异常时，需在中断处理，查找外部存储里是否有之前已经实现过映射的页面，然后加载到内存中，补上所需页面。

## Q2.4.1
当缺页时，访问pte时，会产生缺页异常，因为此时pte所指向的物理页面已经不在内存里，已经被交换到了外部存储器了。当被交换时pte此时所指向的物理页已经不在内存里了，所以会设置一些标志或者一些信息，比如被交换到外部存储器的哪个位置。

## Q3.1.1
进程无论是在内核态还是用户态都是不需要切换页表，因为此时进程的用户态和内核态共用一张表，这个表映射了内核地址空间以及进程用户地址空间，所以不需要切换。但切换进程的时候就需要切换页表，因为即使每个表都映射过内核地址空间但用户地址空间不一样，所以要换页表。通过将新的页表的基地址存储进系统里用来存放页表基地址的寄存器(risc-v里是satp)里，这样就可以使用新的页表。

## Q3.1.2
通过页表里的每个页表项的U标志位来控制访问权限。

## Q3.1.3
触发trap陷入时不需要切换页表，同时做到了取指连续平滑，响应更好，效率更高。

## Q3.1.4
双页表的时候切换进程的时候要换表，触发trap陷入的时候需要换成内核态表；假设我写一个单页表操作系统，我会选择切换进程的时候更换页表。

# 3.看法
希望能学习到其他更多的页帧管理策略以及想了解更多内存布局里地址空间的规划。

# 荣誉准则：
我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。