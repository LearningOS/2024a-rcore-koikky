# 1.总结
对于sys_task_info系统调用，它是在用户级的应用程序调用的，因此在监督级需要完成此次异常控制流的处理。在监督级里会对传入的指针进行操作，若成功返回0，若失败会返回-1。
传入的为TaskInfo类型的一个指针，我需要对此进行赋值，比如当前任务的状态、统计每个系统调用的使用次数、以及任务第一次被调度到查询任务信息之前的最后一次系统调用这段时间。
为此我将TaskInfo作为任务控制块TaskControlBlock的一部分(每个任务控制块都应包含任务信息)。同时为方便记录TaskInfo的time元素(任务第一次被调度到查询任务信息之前的
最后一次系统调用所持续时间)，我还将task_first_time(此元素记录了任务第一次被调度的时刻)元素嵌入结构体TaskControlBlock。我将整个统计操作放在了os部分的syscall函
数里，分不同种类的系统调用分开统计。

# 2.简答作业
## Q1
ch2b_bad_address.rs里出现的问题是试图往一个不正常的地址0x0写入数据0，ch2b_bad_instructions.rs出现的问题是在用户级使用了错误指令sret，ch2b_bad_register.rs
出现的问题是在用户级试图操作csr寄存器sstatus。

## Q2.1
a0常用作不同调用之间传递的第一个参数(a0既可传参也可以作为返回参数)；(1)第一种情景：对于ch3，第一种情景是在任务调度的时候，一个任务第一次调度的时候，都会进入__restore ，
此时a0为__switch的第一个参数当前任务的TaskControlBlock指针。(2)第二种情景：第一种情景是处理异常trap的时候，a0此时是一个内核栈指针。

## Q2.2
将sp指向的内核栈上的这三个特殊偏移位置处的值分别赋值在临时寄存器t0、t1、t2，再将这三个临时寄存器里的值赋值给sstatus、sepc、sscratch这三个csr寄存器。这些寄存器在返回
用户态起到重要作用，sstatus决定执行sret后系统该返回用户级，sepc决定执行sret后系统将pc寄存器赋值为用户级的某处代码，sscratch负责交替保存两个特权级的栈指针。

## Q2.3
跳过x2是因为x2对应的用户栈指针保存到了sscratch寄存器, 不需要从内核栈中进行恢复，跳过x4是因为并没有使用它, 所以无需恢复。

## Q2.4
sp为程序的用户栈指针，sscratch为该程序的内核栈指针。

## Q2.5
sret；sret执行后系统会根据sstatus里存储的值决定返回哪个特权级，对于每个任务，无论在初始化内核栈的时候还是触发trap进入监督级的时候，前者是在内核栈里直接存储sstatus的值
为0，后者会在从用户级进入监督级时，硬件自动写入0到sstatus里，然后再将sstatus的值存储到内核栈。所以这里的sret执行后总是会进入用户级。

## Q2.6
sp为该程序的内核栈指针，sscratch为该程序的用户栈指针。

## Q2.7
程序在运行时，U态主动进入S态是使用ecall，被动的话就是触发trap。

# 3.看法
希望这阶段的练习的问题和要求能讲的详细点，练习里的有些地方有时会产生歧义与未理解题目的意图。

# 荣誉准则：
我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本
实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。